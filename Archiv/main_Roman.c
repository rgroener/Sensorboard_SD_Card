/*

	Demo of glcd library with AVR8 microcontroller
	
	Tested on a custom made PCB (intended for another project)

	See ../README.md for connection details

*/

#include <avr/io.h>
#include "glcd/glcd.h"
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include "glcd/fonts/Liberation_Sans15x21_Numbers.h"
#include "glcd/fonts/font5x7.h"
#include <avr/pgmspace.h>
#define F_CPU 16000000UL  // 1 MHz

#define T_RED !(PIND & (1<<PD5)) && (entprell == 0)
#define T_BLUE !(PIND & (1<<PD6)) && (entprell == 0)
#define T_GREEN !(PIND & (1<<PD2)) && (entprell == 0)
#define RELOAD_ENTPRELL 80
#define FWD 0
#define BWD 1 

/* Function prototypes */
static void setup(void);

static void setup(void)
{
	/* Set up glcd, also sets up SPI and relevent GPIO pins */
	glcd_init();
}
uint16_t zaehler;
char string[8] = "";
uint8_t ms, ms10,ms100,sec,min,entprell, state;
uint8_t end_ms100, end_sec, end_min;
uint8_t direction;
enum state{WAIT, COUNT, TIME, TIME_WAIT,FLIGHT_TIME};

ISR (TIMER1_COMPA_vect)
{
	ms10++;
	if(entprell != 0)entprell--;
	if(ms10==10)	//10ms
	{
		ms10=0;
		ms100++;
	}
    if(ms100==10)	//100ms
	{
		ms100=0;
		sec++;
	}
	if(sec==60)	//Minute
	{
		sec=0;
		min++;
	}
}

const unsigned char bitmap[] PROGMEM= 
{ 
	 0x3e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 
	 0xfe, 0xfe, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 
	 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xf8, 0xf8, 
	 0xf8, 0xf8, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0xe0, 0xf8, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xfc, 
	 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 
	 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 
	 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x3e, 0x28, 0x00, 0x00, 0x01, 0x03, 
	 0x07, 0x07, 0x07, 0x8f, 0xcf, 0xcf, 0xcf, 0xcf, 0xc7, 0xc7, 0xe7, 
	 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 
	 0xf3, 0xfb, 0xfb, 0xf3, 0x87, 0x5f, 0x7f, 0xff, 0xff, 0xff, 0xfa, 
	 0xf8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xf8, 0xff, 
	 0xff, 0xff, 0xff, 0x3f, 0x83, 0xa3, 0xf3, 0xfb, 0xf3, 0xf3, 0xf3, 
	 0xf3, 0xf3, 0xf3, 0xf3, 0xe3, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xc7, 
	 0xc7, 0xc7, 0xcf, 0xcf, 0xcf, 0xcf, 0x8f, 0x07, 0x07, 0x03, 0x03, 
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	 0x07, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x9f, 
	 0x9f, 0x9f, 0xcf, 0xcf, 0xe7, 0xe7, 0xf7, 0xf3, 0xfb, 0xfb, 0xf9, 
	 0xfc, 0xfc, 0xf4, 0xf1, 0x47, 0x1f, 0x1f, 0x3f, 0xff, 0xfe, 0xf8, 
	 0xf8, 0xf8, 0xfe, 0x7e, 0x7f, 0x3f, 0x1f, 0x67, 0x65, 0xf1, 0xfc, 
	 0xfc, 0xfc, 0xf9, 0xfb, 0xf3, 0xe7, 0xe7, 0xe7, 0xcf, 0xcf, 0xcf, 
	 0x9f, 0x9f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0f, 
	 0x07, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x0f, 0x0f, 0x1f, 0x3f, 0x3f, 
	 0x3f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0xe7, 0xf5, 0xf8, 0xfc, 
	 0xff, 0xff, 0x7f, 0x7f, 0x3e, 0x01, 0x01, 0x01, 0x01, 0x01, 0x16, 
	 0x3e, 0x7f, 0xff, 0xfe, 0xfe, 0xfd, 0xfb, 0xe7, 0xa7, 0x0f, 0x1f, 
	 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0f, 0x07, 0x02, 
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0xf0, 0x90, 0x90, 0x90, 0x60, 0x00, 0x00, 0x80, 
	 0x40, 0x40, 0x40, 0x80, 0x00, 0xc0, 0x80, 0x40, 0xc0, 0x80, 0x40, 
	 0x40, 0x80, 0x00, 0x00, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0xc0, 
	 0x80, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x10, 
	 0x90, 0x90, 0xa0, 0x00, 0x00, 0xc0, 0x40, 0x40, 0x00, 0x80, 0x48, 
	 0x40, 0x48, 0x80, 0x00, 0xc0, 0x80, 0x40, 0x40, 0x80, 0x00, 0x80, 
	 0x40, 0x40, 0x40, 0x80, 0x00, 0xc0, 0x80, 0x40, 0x40, 0x00, 0x00, 
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x03, 0x04, 0x04, 0x04, 0x03, 
	 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 
	 0x07, 0x05, 0x05, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 
	 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x04, 0x04, 0x03, 0x00, 
	 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x04, 0x03, 0x00, 
	 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03, 0x05, 0x05, 0x05, 0x01, 
	 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };

int main(void)
{
	

	
	/* Backlight pin PL3, set as output, set high for 100% output */
	DDRB |= (1<<PB2);
	//PORTB |= (1<<PB2);
	PORTB &= ~(1<<PB2);
	
	DDRC &= ~(1<<PC0); 	//Eingang Hallsensor
	PORTC |= (1<<PC0);	//Pullup Hallsensor einschalten
	
	DDRC |=(1<<PC1); 	//Eingang Hallsensor
	PORTC |= (1<<PC1);	//Pullup Hallsensor einschalten
	
	
	DDRD &= ~((1<<PD6) | (1<<PD2) | (1<<PD5)); 	//Taster 1-3
	PORTD |= ((1<<PD6) | (1<<PD2) | (1<<PD5)); 	//PUllups fÃ¼r Taster einschalten
	
	DDRD &= ~(1<<PD4); //T0 Counter Input
	TCCR0B |= (1<<CS02) | (1<<CS01) | (1<<CS00);//Counter 0 enabled clock on rising edge
	
	//Timer 1 Configuration
	OCR1A = 0x009C;	//OCR1A = 0x3D08;==1sec
	
    TCCR1B |= (1 << WGM12);
    // Mode 4, CTC on OCR1A

    TIMSK1 |= (1 << OCIE1A);
    //Set interrupt on compare match

    TCCR1B |= (1 << CS12) | (1 << CS10);
    // set prescaler to 1024 and start the timer

    sei();
    // enable interrupts
	
	setup();
	
	glcd_clear();
	glcd_write();
	zaehler=0;
	ms=0;
	ms10=0;
	ms100=0;
	sec=0;
	min=0;
	state=WAIT;
	entprell=0;
	end_ms100=0;
	end_sec=0;
	end_min=0;
	direction = FWD;
	
	while(1) 
	{
		
		switch(state)
		{
			case WAIT:	glcd_tiny_set_font(Font5x7,5,7,32,127);
						glcd_clear_buffer();
						glcd_draw_bitmap(bitmap);
						glcd_write();	
						
						
						/*glcd_tiny_draw_string(0,0,"PIPER   PA18");
						glcd_tiny_draw_string(0,2,"Ready to get");
						glcd_tiny_draw_string(0,3,"");*/
						
						if(T_GREEN)
						{
							entprell=RELOAD_ENTPRELL;
							entprell=50;
							state=COUNT;
							TCNT0=0;
							zaehler=0;
							glcd_set_font(Liberation_Sans15x21_Numbers,15,21,46,57);
							glcd_clear();
						}
						break;

			case COUNT:	glcd_clear_buffer();
						if(direction==FWD)	//winding direction forward = add new winds
						{
							zaehler+=TCNT0;
							
						}else zaehler-=TCNT0;//winding direction forward = subtract new winds
						TCNT0=0;
						sprintf(string,"%01d",zaehler);
						glcd_draw_string_xy(0,0,string);
							
						
						if(T_GREEN)
						{
							entprell=RELOAD_ENTPRELL;
							state=TIME_WAIT;
							glcd_clear_buffer();
							glcd_tiny_set_font(Font5x7,5,7,32,127);
							glcd_tiny_draw_string(0,1,"Timer is ready");
							glcd_tiny_draw_string(0,2,"Green > Start");
							
						}
						if(T_RED)//reset Counter
						{
							entprell=RELOAD_ENTPRELL;
							TCNT0=0;
							zaehler=0;
							direction=FWD;
							glcd_clear();
						}
						
						if(T_BLUE)//Change winding direction
						{
							entprell=RELOAD_ENTPRELL;
							if(direction==FWD)
							{
								direction = BWD;
							}else direction = FWD;
						}
						break;
												
			case TIME_WAIT:	if(T_GREEN)
							{
								entprell=RELOAD_ENTPRELL;
								state=TIME;
								ms10=0;
								ms100=0;
								sec=0;
								min=0;
								glcd_set_font(Liberation_Sans15x21_Numbers,15,21,46,57);
								glcd_clear();
							}
							break;
							
			case TIME:		glcd_clear_buffer();
							sprintf(string,"%01d",min);
							glcd_draw_string_xy(0,0,string);
							glcd_draw_string_xy(15,0,0);
							
							sprintf(string,"%02d",sec);
							glcd_draw_string_xy(20,0,string);
							glcd_draw_string_xy(50,0,0);
							
							sprintf(string,"%d",ms100);
							glcd_draw_string_xy(55,0,string);
							
							if(T_GREEN)
							{	
								entprell=RELOAD_ENTPRELL;
								end_min=min;
								end_sec=sec;
								end_ms100=ms100;
								
								state=FLIGHT_TIME;
								glcd_clear_buffer();
								glcd_tiny_set_font(Font5x7,5,7,32,127);
								glcd_tiny_draw_string(0,0,"Flight Result");
								
								/*
								 * eine Linie Text entspricht 15 pixel bei Zhlenausgabe*/
								
								glcd_tiny_draw_string(0,2,"Time:");
								
								sprintf(string,"%02d",end_min);
								glcd_draw_string_xy(38,16,string);
								glcd_draw_string_xy(50,16,0);
								
								sprintf(string,"%02d",end_sec);
								glcd_draw_string_xy(55,16,string);
								glcd_draw_string_xy(67,16,0);
								
								sprintf(string,"%02d",end_ms100);
								glcd_draw_string_xy(72,16,string);
								
								glcd_tiny_draw_string(0,3,"Winds:");
								sprintf(string,"%d",zaehler);
								glcd_draw_string_xy(38,24,string);
							}
							
							break;
			case FLIGHT_TIME:	if(T_RED)
								{
									entprell=RELOAD_ENTPRELL;
									zaehler=0;
									ms=0;
									ms10=0;
									ms100=0;
									sec=0;
									min=0;
									state=WAIT;
									direction=FWD;
									entprell=0;
									end_ms100=0;
									end_sec=0;
									end_min=0;
								}
								break;
		}//End of switch
				
		
	
	glcd_write();
	}//End of while
	
	return 0;
}//end of main
